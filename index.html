<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Django Tutorial</title>
    <link href="style.css" type="text/css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Cousine|Nanum+Gothic+Coding&display=swap" rel="stylesheet">


</head>
<body>

<nav id="navbar" class="sidenav">
    <header>Django: Inception to Deploy</header>
    <a href="#basic_assumptions" class="nav-link"> Basic Assumptions</a>
    <a href="#install_dependencies" class="nav-link">Install Dependencies</a>
    <a href="#getting_started" class="nav-link">Getting Started</a>
    <a href="#database_setup" class="nav-link">Database Setup</a>
    <a href="#models" class="nav-link">Models</a>
    <a href="#using_django_admin" class="nav-link">Using Django Admin</a>
    <a href="#views_urls" class="nav-link">Views & Urls</a>
    <a href="#adding_forms" class="nav-link">Adding Forms</a>
    <a href="#update_delete" class="nav-link">Update and Delete</a>
    <a href="#connecting_stylesheet" class="nav-link">Connecting a Stylesheet</a>
    <a href="#deploy" class="nav-link">Deploy!</a>
    <a href="#credits_and_links" class="nav-link">Credits & Links</a>

</nav>

<main id="main-doc">
    <section class="main-section" id="basic_assumptions">
        <header class="heading"> Basic Assumptions</header>
        <h3>Working with django and python in this tutorial makes some assumptions about pre-requisite comfort with the
            development of websites in general:
        </h3>
        <ul>
            <li>You know how to connect to files root directories and make new files within that structure</li>
            <li>You have a working knowledge of terminal commands</li>
            <li>You have a grasp of python syntax and some experience using the language</li>
            <li>You have some experience with backend views</li>
            <li>You are comfortable with basic CSS and HTML</li>
            <li>You can troubleshoot and debug if issues come up as you work through the tutorial steps</li>
        </ul>
    </section>
    <section class="main-section" id="install_dependencies">
        <header class="heading">Install Dependencies</header>
        <p>For django applications, you will need to install python and a tool that creates virtual environments called
            pipenv. Check your system to see which version of python you have available. You can also check for
            pipenv by using the following terminal commands: </p>
        <code> $ python3 --version </code>
        <br>
        <code> $ pipenv --version </code>

            <p>I recommend Python 3.7 or higher for best performance. If you need to install either program use
                Homebrew to install them globally with these commands: </p>
        <code> $ brew install python </code>
        <br>
        <code> $ brew install pipenv </code>
        <p> Now you need to create a directory for your project. My application is a simple 'todo' list that I am
            calling 'honeyDo-django'. Once you make this directory, you will need to cd into it for the next round
            of installations. </p>
        <code> $ mkdir honeyDo-django </code>
        <p> OR <br> You can create a corresponding GitHub repo, initialize it with a README.md, and clone
            into it for easy git connection to make the root directory. </p>
        <code> $ git clone &ltREPO URL> </code>
        <br>
        <code> $ cd honeyDo-django/ </code>
        <p> Now you are going to use pipenv to install locally inside your project. It is important NOT to install
            these dependencies globally! Also, unlike npm, you will need to type out 'install' as 'i' doesn't work.
            The first installation will be django itself. The second is a library that will connect django to
            postgreSQL which will be hosting the database information. </p>
        <code> $ pipenv install django </code>
        <br>
        <code> $ pipenv install psycopg2-binary </code>

    </section>

    <section class="main-section" id="getting_started">
        <header class="heading">Getting Started</header>
        <p>Now when you open the project in a text editor, you will see two new files have been added: Pipfile and
            Pipfile.lock. These function as a holding place for all dependencies and works similarly to node_modules,
            but do not require gitignore. The next step is to start the project itself. Naming convention can make
            this a little confusing, so be sure to know which directory is the root of the project and which one is
            the application itself. </p>
        <code> $ pipenv run django-admin startproject honeyDo_django . </code>
        <p> A few things to notice. First, you can substitute any name for your project after the startproject
            command, but best practice is to use snake_case for python/django. Second, the . at the end of the
            command is important so you don't create a sub-folder within the project. Finally, when you return to
            your text editor, you will see several new files have been created automatically. Now it is time to enter
            the virtual environment inside the project. Use this command to enter: </p>
            <code> $ pipenv shell </code>
            <p> You should notice a change in your bash command. Depending on the individual set up, it may
                explicitly say 'virtual env' or 'env' OR it may put your project name in front of the $. If this
                command doesn't work, you can also try: </p>
        <code> $ source .env/bin/activate </code>
        <p> Once inside the virtual environment, you need to create the application files. This time you will not
            need the . at the end.</p>
        <code> $ django-admin startapp honeyDo_app </code>
        <p> If django-admin doesn't work for some reason, you can replace it with <code>python3 manage.py</code> as
            long as that file exists in the current directory.
        </p>
    </section>
        <section class="main-section" id="database_setup">
            <header class="heading">Database Setup</header>
        <p> Now that all the django files are in place, it is time to switch gears and set up the database. For this
        project, you will use PostgreSQL, which is a more robust relational database than the default SQLite. If you
        need to install this locally, please follow <a href="https://www.postgresql.org/download/">this link</a> and
        select the appropriate version for your home machine. Once the application is installed and running, return to
            the terminal and open a new tab. You do not need to cd into the project to set up this database, but you
        will need to make note of the values entered since they will need to be inputted into the settings of your
            django project as well. First use this command to login to PostgreSQL:</p>
            <code> $ psql -d postgres </code>
            <p> You should enter into a new field within the terminal. The prompt may have '>' or 'postgres=#' to
                show access to the application. Now, create a database using the following commands: (Please note the uppercase may not be
                necessary on all operating systems.) PostgreSQL is case sensative and all database names MUST be
                lowercase. Also note the syntax with 'password' and ; at the end of the commands. You should get
                confirmation in the terminal after each command is executed. As always, you can change the values of
                the project to match your application and desired user name and password.
            </p>
            <code> CREATE DATABASE honeydo;</code><br><code> CREATE USER honeyuser WITH PASSWORD 'honey'; </code>
            <br> <code> GRANT ALL PRIVILEGES ON DATABASE honeydo TO honeyuser; </code> <br> <code> \q </code>
            <p> Now that the database is created, return to your text editor. Inside the project directory you need
                to find (around line 76) and enter the database information into the <code>settings.py</code> file as
                follows:
            </p>
<code> <pre>
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
         'NAME': 'honeydo',
         'USER': 'honeyuser',
         'PASSWORD': 'honey',
         'HOST': 'localhost',
    }
}</pre></code>
            <p> You will also need to include the name of the application at the bottom of the INSTALLED_APPS list
                (around line 33). Please note this must match the name of the directory, NOT the database.</p>
            <code> <pre>
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'honeyDo_app',
] </pre></code>
            <p> Now, finally, you can run this terminal command and navigate to localhost:8000 to see a welcome
                Django app page!</p>
            <code> $ python3 manage.py runserver </code>
            <img src="./images/django-confirm.png" alt="confirmation page with django rocket"/>
            <p> To see a list of commands simply type <code>python3 manage.py</code> or visit <a
                    href="https://docs.djangoproject.com/en/2.1/ref/django-admin/">djangoproject.com</a> for
                full documentation on django-admin/manage.py.</p>
    </section>
    <section class="main-section" id="models">
        <header class="heading">Models</header>
        <p> It's time to create the interface that will allow you to generate data for the database. Models are
            built using python classes. This class will determine the information you want to be added to each
            instance of the model. In this case, I want a model 'Todo' that will hold all the 'todo' items so that
            model will need fields for a title, date, and person (who will be doing the list). Since I want to have
            many items possible on my single 'Todo' list, I will also need a second model that will have ForeignKey
            relationship to the 'Todo' list. Open the <code>models.py</code> file and add the following:</p>
        <code><pre>
from django.db import models
from datetime import date

# Create your models here.
class Todo(models.Model):
    title = models.CharField(max_length=180)
    date = models.DateField(auto_now=False, auto_now_add=False, default=date.today)
    person = models.CharField(max_length=100)

    def __str__(self):
        return self.title

class Item(models.Model):
    task = models.CharField(max_length=300)
    todo = models.ForeignKey(Todo, on_delete=models.CASCADE, related_name='items')

    def __str__(self):
        return self.task</pre></code>
        <p> In order to use this model, it must be migrated to the database. These two
            commands will not only
            configure the database information, but also store a record of the work inside the migrations directory
            in your project. Visit <a href="https://docs.djangoproject.com/en/2.1/topics/migrations/">djangoproject
                .com</a> for the full documentation on migrations. Green <span style="color:green;">OK</span> will
            indicate everything worked. Now, you can have as many models and fields as you want, but I recommend
            keeping it simple since this is a relational database and too many relationships will quickly get
            challenging to manage! (You will need to quit the server before running the commands.)
        </p>
        <code> $ python3 manage.py makemigrations </code>
        <br>
        <code> $ python3 manage.py migrate </code>
    </section>
    <section class="main-section" id="using_django_admin">
        <header class="heading">Using Django Admin</header>
        <p> One of the reasons I love django is that it comes with an admin authentication that will allow you to
            access all the CRUD features without needing any other interface. In order to access this feature, you
            need to create a superuser and password. Unlike the database user/password, keep this information safe
            and private since it grants access to all the pieces of your app! To set it up, run this command in
            the terminal and fill out the fields.</p>
        <code> $ python3 manage.py createsuperuser </code>
        <p> Now, open the <code>admin.py</code> file and add the following code:</p>
        <code><pre>
from django.contrib import admin
from .models import Todo, Item

# Register your models here.
admin.site.register(Todo)
admin.site.register(Item)</pre></code>
<p> Finally you can access your database! You will need to run <code> $ python3 manage.py runserver </code> in the
    terminal first whenever accessing localhost, but once that is running, navigate to <a href="http://localhost:8000/admin ">
    localhost</a> to login and view your app. So far these models can make todo lists and tasks that can be assigned to the lists. However, you will also notice that the
    tasks don't show up in the lists. Don't worry, that will come soon when you add the user views to the project.
    </p>
<img src="./images/django-admin-home.png" alt="successful login screen example"/>
        <p>(I love how the datetime automatically adds a mini-calendar to the application! This will come in handy later as
            well.)</p>
        <img src="./images/django-admin-calendar.png" alt="sample todo with mini calendar"/>
        <p> On a side note, you might want to seed your database before doing any of this. If you have data already
            in place, you can visit
            <a href="https://docs.djangoproject.com/en/2.1/howto/initial-data/">djangoproject.com</a> for the full
            documentation on seed data formats. Definitely take a few minutes to add a couple of entries in both the
            Items and the Todos so you have something to pull when building out the user interface.
        </p>
    </section>
    <section class="main-section" id="views_urls">
        <header class="heading">Reading Views & Urls</header>
        <p> Great! You have a working app, but this isn't terribly practical for a user. Next you will need to
            navigate into the <code>views.py</code> file from the application directory. This is where the python code
            will create an interface through Django that is similar to HTML pages. Begin by adding the following to
            line 2 (under the django.shortcuts import) to access the models:
        </p>
        <code>from .models import Todo, Item</code>
        <p> Next, you need to create a python method that will render a list of all the Todo lists created in the admin
        console. Notice the request is followed by an html page. This will be set up in a moment.</p>
        <code><pre>
def todo_list(request):
    todos = Todo.objects.all()
    return render(request, 'todo_list.html', {'todos': todos})</pre></code>
        <p> Users of this program will want to see one todo list at a time. Note the conversion of id to pk. Id is automatically assigned to JSON data,
            but pk (primary key) is what is used by the database and django which will be important for building out
            the html pages.
        </p>
        <code><pre>
def todo_detail(request, pk):
    todo = Todo.objects.get(id = pk)
    return render(request, 'todo_detail.html', {'todo': todo})
        </pre></code>
        <p> In order to access these views in the browser, django requires a path to the URL, much like a controller
            in Express. Since these are paths connected to the app itself, you will need to create a new file inside
            the application directory to hold them called <code>urls.py</code> and you will enter the following code:
            (Do not use the urls.py file inside the project directory!)
        </p>
        <code><pre>
from django.urls import path
from . import views

urlpatterns = [
    path('', views.todo_list, name = 'todo_list'),
    path('todo/&ltint:pk>', views.todo_detail, name = 'todo_detail'),
]</pre></code>
        <p>Notice the syntax for the two paths created. The url path is first followed by the call to the python
            method. The name refers to which html template will be rendered, which is the next step. In this case, the
            'homepage' will be the list of all the Todo lists. To make that work, you first need a directory that
            will hold all the html files called <code>templates</code> and inside that directory, another new file
            labeled <code>base.html</code>. Make sure this file system remains inside the application directory where
            the views and urls are also stored so your filing structure looks something like this:
        </p>
<img src="./images/file_structure.png" alt="sample folder set up"/>
        <p> The two green files are the ones just created. Inside that <code>base.html</code> is where the HTML
            boilerplate will go. I set up mine to look like this.</p>
<code><pre>
&lt!DOCTYPE html>
&lthtml lang="en">
&lthead>
    &ltmeta charset="UTF-8">
    &lttitle>HoneyDo-Django&lt/title>
    &lt/head>
&ltbody>
&ltnav >
    &ltul >
        &ltli >&lta href="/">Home&lt/a>&lt/li>
    &lt/ul>
&lt/nav>
&ltdiv >
    {% block content %}
    {% endblock %}
&lt/div>
&lt/body>
&lt/html>
</pre></code>
 <p> The stuff inside the curly braces will be how Django connects to the browser. It is very similar to Handlebars
     (HBS) in Express. Now you need another template for each of the two views, so make these two files inside the
     templates directory. I find it easier to create these files without a boilerplate since the pages will be
     loading the content inside the div and copying the base html automatically.</p>
        <code>todo_list.html</code>
        <br>
        <code>todo_detail.html</code>
        <p>Inside the <code>todo_list.html</code> file, add the following code: </p>
        <code><pre>
{% extends 'base.html' %}

{% block content %}
&lth2 >Todo List&lt/h2>
&ltdiv>
    &ltul>
        {% for todo in todos %}

        &ltli >
            &lta href="{% url 'todo_detail' pk=todo.pk %}">
                {{ todo }}&lt/a>
        &lt/li>
        {% endfor %}
    &lt/ul>
&lt/div>
{% endblock %}</pre></code>
        <p>Let's break down what just happened. The first line extends the boilerplate from the base.html file so
            all html tags can be used. After that, the content inside the block will be inserted into the body div
            from the base.html file. This content includes an h2 title followed by an unordered list of all the Todos
            from the data entered earlier in the admin console. To list them, Django needs a 'for' loop. Notice the list items holds a reference to the todo_detail. This link gives the user access to
            each individual Todo list according to the primary key number it has been assigned by Django.</p>
        <p> Now you need something similar in the <code>todo_detail.html</code> file.
        </p>
        <code><pre>
{% extends 'base.html' %}

{% block content %}
&lth2 >{{todo.title}}&lt/h2>
&ltdiv>
    &lth4>List created on: {{todo.date}}&lt/h4>
    &lth4>{{todo.person}} will complete these tasks today!&lt/h4>
&lt/div>
{% endblock %}</pre></code>
            <p> Using dot notation inside the double {{}} you can access all of the fields from the Todo model. I
                created additional text for clarity, but feel free to add anything you wish.
        </p>
        <p>The final step before revisiting the localhost is to add all these application paths to the <code>urls .py</code>
            file inside the project directory by importing 'include' and adding the app urls. If you changed the name of your application, make sure the
            file name matches the include path.
        </p>
        <code><pre>
from django.contrib import admin
from django.urls import path
from django.conf.urls import include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('honeyDo_app.urls')),
]</pre></code>
<p> Once again start up the server with <code> $ python3 manage.py runserver </code>, hope there aren't any
    errors, and navigate to <a href="http://localhost:8000 ">localhost</a> to see your work. The home page should
    look something like this:
</p>
        <img src="./images/home_screen.png" alt="sample homescreen"/>
        <p>The single Todo list should look similar to this:</p>
        <img src="images/single_todo.png" alt="sample todo list"/>
        <p> Notice that the items attached to the list still aren't visible. Let's fix that. Go back to the
            <code>views.py</code> file. Right now there are only methods for viewing the Todo model so you need to
            repeat the process for the Item model in order to access the tasks. First make the list and detail views
            by adding this code under the existing lines: </p>
        <code><pre>
def item_list(request):
    items = Item.objects.all()
    return render(request, 'item_list.html', {'items': items})

def item_detail(request, pk):
    item = Item.objects.get(id = pk)
    return render(request, 'item_detail.html', {'item': item})</pre></code>
        <p>Next you need to make matching application paths in the <code>urls.py</code> file inside the application
            directory. Enter the next two paths under the 'todo/&ltint:pk>' entry. Make sure to have commas after
            each url!</p>
        <code><pre>
path('items/', views.item_list, name = 'item_list'),
path('item/&ltint:pk>', views.item_detail, name= 'item_detail'),</pre></code>
        <p>Now create two new html files in the templates directory with the corresponding item names. Inside the <code>item_list.html</code> file, add the following:</p>
    <code><pre>
{% extends 'base.html' %}

{% block content %}
&lth2 >Item List&lt/h2>
&ltdiv>
    &ltul>
        {% for item in items %}

        &ltli >
            &lta href="{% url 'item_detail' pk=item.pk %}">
                {{ item }}&lt/a>
        &lt/li>
        {% endfor %}
    &lt/ul>
&lt/div>
{% endblock %}</pre></code>
        <p>This created a simple list with links to each item in the same way you made the Todo list. Inside the
            <code>item_detail.html</code> file, add something like what is below. Feel free to be creative when
            adding information to make it clear to the user what is being accessed on each page.</p>
        <code><pre>
{% extends 'base.html' %}

{% block content %}
&lth2>{{item.task}}&lt/h2>

{% endblock %}</pre></code>
        <p> In order to see what you just did, you have to manually add '/items' after navigating to your <a
                href="http://localhost:8000/">localhost</a>. Having a link to each item only to display the name of
            the task isn't terribly useful, for this application, but when there are more fields tied to the foreign key this step is essential. Have a look
            at another Django application, <a href="https://lessonkeeper.herokuapp.com/">lessonKeeper</a>, I created for a more complicated example of this .</p>
    <p> All this work still doesn't link the todo and items, but the framework is there so you can now access the
        Item model. Return to the <code>todo_detail.html</code> file and enter this new loop after the second 'h4'
        tag: </p>
        <code><pre>
&ltul>
        {% for item in todo.items.all %}
        &ltli>{{ item.task }}
        &ltbr/> &lt/li>
        {% endfor %}
&lt/ul></pre></code>
        <p>Refresh the browser and the page will now display a bullet list of the tasks!  </p>
        <img src="./images/todo_with_tasks.png" alt="sample list of tasks"/>
    </section>
    <section class="main-section" id="adding_forms">
        <header class="heading">Adding Forms</header>
        <p>Now that the user can read all the data, you need to add a form so users can create new todos from the
            browser. Make a new <code>forms.py</code> file in the application directory. At the top of the file you
            need to import forms and the two models using this code:</p>
        <code>from django import forms</code><br><code>from .models import Todo, Item</code>
        <p>Now you will make the form itself. The syntax is very similar to the model and you want to be sure all
            the fields are present or you won't be able to add that piece of the data to the new todo. Also not the
            dangling , inside the fields data. </p>
        <code><pre>
class TodoForm(forms.ModelForm):

    class Meta:
        model = Todo
        fields = ('title', 'date', 'person',)

class ItemForm(forms.ModelForm):

    class Meta:
        model = Item
        fields = ('task', 'todo',)</pre></code>
        <p>Next you need to create an html page for each form. Let's start with the todo form. In the templates
            directory, create a <code>todo_form.html</code> file. Inside that file add this code:</p>
        <code><pre>
{% extends 'base.html' %}

{% block content %}
&lth1>Honey Todo&lt/h1>
&ltform method="POST">
    {% csrf_token %}
    {{ form.as_p }}
    &ltbutton type="submit">Save&lt/button>
&lt/form>
{% endblock %}</pre></code>
        <p>Let's break down what just happened. The python code we added in <code>forms.py</code> will automatically
            generate this form for us! All you need to have is the type of method used: POST, and Django does the
            rest. This form is created as paragraphs, but if you would like more flexibility, there is much more
            information on <a href="https://docs.djangoproject.com/en/3.0/ref/forms/fields/">djangoproject.com</a>
            about how to change the data fields. My favorite piece about the django forms is the built in use of
            'csrf_token' that lends some security to the form without any extra effort on your part. </p>
        <p> Before you can see this new form in the browser, you need a bit more code. Return to the <code>views
            .py</code> file in the application directory. On the top line you must add <code>, redirect</code> to the
            django shortcuts. This will allow you to redirect to a different page after submitting the data from the
            form. Also, on line three, you must import the forms by adding <code>from .forms import TodoForm,
                ItemForm</code> </p>
        <p> I prefer to organize all my methods by model, so I will add the next piece between the todo_detail and item_list. However, the application will also work if you
            continue to add code to the bottom of the page.
        </p>
        <code><pre>
def todo_create(request):
    if request.method == 'POST':
        form = TodoForm(request.POST)
        if form.is_valid():
            todo = form.save()
            return redirect('todo_detail', pk=todo.pk)
    else:
        form = TodoForm()
    return render(request, 'todo_form.html', {'form': form})</pre></code>
        <p>This method creates a form, checks for the validity of the form, saves the data, and redirects the user
            back to the individual page for the new todo item. Now you need to add a path in the application
            <code>urls.py</code> file so the browser will render the form. Simply add <code>path('todo/new',
                views.todo_create, name = 'todo_create'),</code> on line 9.</p>
        <img src="./images/todo_form.png" alt="todo form example"/>
        <p>That last piece should allow you to return to the browser and view your <a
                href="http://localhost:8000/todo/new">New Todo</a> form. Notice again the missing tasks from the
            form above. To add them, repeat the process of adding the <code>item_form.html</code> file, making a create for the Item
            model in <code>views.py</code>, and adding <code>path('item/new', views.item_create, name = 'item_create'),</code> to the <code>urls.py</code> file in the application
        directory. Remember <a href="http://localhost:8000">localhost</a> will need to have '/item/new' added
            manually to view this form. </p>
        <img src="./images/task_form.png" alt="task form example"/>
        <p>Notice the drop down menu that is automatically added to this form? That is the foreign key
            relationship at work! Now typically, there is more data when building out
            two separate html pages of forms, however, I felt it was important to give the full detail so this
            tutorial could be applied to future, more complex projects.
        </p>
        <p>In some cases it may be helpful to convert the data into json pieces to make it easier for front end
            technologies to 'talk' to the backend parts. A serializer also allows data to be validated and works with
            the form data you just entered to do that. None of this is necessary for this application, but visit
            <a href="https://www.django-rest-framework.org/api-guide/serializers/">Django REST Framework </a> to see the documentation.</p>
    </section>
    <section class="main-section" id="update_delete">
        <header class="heading">Update and Delete</header>
        <p>The current format for creating new forms is terribly impractical for the user so we will add the link to
            tasks through the update feature of the todo form. The tricky piece is that the tasks cannot function independently of a primary
            todo list, so the todo must be created first.
        </p>
        <p> To start this process, you need to add an update method to the <code>views.py</code> file. This is very
        similar to the create method and will actually redirect to the same form as before.
        </p>
        <code><pre>
def todo_update(request, pk):
    todo = Todo.objects.get(pk=pk)
    if request.method == "POST":
        form = TodoForm(request.POST, instance=todo)
        if form.is_valid():
            todo = form.save()
            return redirect('todo_detail', pk=todo.pk)
    else:
        form = TodoForm(instance=todo)
    return render(request, 'todo_form.html', {'form': form})</pre></code>
        <p>Now, the browser needs the update path in the application <code>urls.py</code> file. For this path, you
            are going to enter a combination of the pk code and the word 'update' by entering
            <code>path('todo/&ltint:pk>/update', views.todo_update, name = 'todo_update'),</code> under the list of
            current paths. These additions should allow you to navigate to <a
                    href="http://localhost:8000/todo/1/update">localhost</a> and view the update form. Notice the page looks identical to the 'new' todo page. The only difference is  this form has the
            information already entered. To update, simply change the text and hit submit. Unfortunately, the tasks
            are still missing. Return to the <code>views.py</code> file and enter the update item method:</p>
        <code><pre>
def item_update(request, pk):
    item = Item.objects.get(pk=pk)
    if request.method == "POST":
        form = ItemForm(request.POST, instance=item)
        if form.is_valid():
            item = form.save()
            return redirect('item_detail', pk=item.pk)
    else:
        form = ItemForm(instance=item)
    return render(request, 'item_form.html', {'form': form})</pre></code>
    <p>Then add the item update path to the application <code>urls.py</code> file, again creating the path at the
        end of the list.</p>
        <code>path('item/&ltint:pk>/update', views.item_update, name = 'item_update'),</code>
        <p>Visit <a>localhost</a> to see this form at work. Again, this isn't super user friendly, so for the
            purpose of this particular project, we are going to make a few small changes. Start with the
            <code>views.py</code> file. We are going to change the redirect for the Item create and Item update to the
            todo_detail.</p>
        <code><pre>
def item_create(request):
    if request.method == 'POST':
        form = ItemForm(request.POST)
        if form.is_valid():
            item = form.save()
            return redirect('todo_detail', pk = item.todo.pk)
    else:
        form = ItemForm()
    return render(request, 'item_form.html', {'form': form})

def item_update(request, pk):
    item = Item.objects.get(pk=pk)
    if request.method == "POST":
        form = ItemForm(request.POST, instance=item)
        if form.is_valid():
            item = form.save()
            return redirect('todo_detail', pk = item.todo.pk)
    else:
        form = ItemForm(instance=item)
    return render(request, 'item_form.html', {'form': form})</pre></code>
        <p>Next we need to return to the <code>todo_detail.html</code> file in the templates directory to add a link
        to the item form. Below the closing div tag, add this line of code:</p>
        <code>&lta href="{% url 'item_create' %}">add task&lt/a></code>
        <p>Great! Now that we can add an item to the todo, we will want to be able to update the current list as
            well. The easiest way is to make each list item a clickable link like this:
        </p>
        <code><pre>
&ltul>
        {% for item in todo.items.all %}
        &ltli>&lta href="{% url 'item_update' pk=item.pk %}">{{ item.task }}&lt/a>
        &ltbr/> &lt/li>
        {% endfor %}
&lt/ul></pre></code>
        <p>The final piece of this section is adding the ability to delete an Item or the entire Todo list. Again
            start with creating the methods to do this in the <code>views.py</code> file.</p>
        <code><pre>
def todo_delete(request, pk):
    Todo.objects.get(id=pk).delete()
    return redirect('todo_list')

def item_delete(request, pk):
    item = Item.objects.get(pk=pk)
    parent_id = item.todo.pk
    item.delete()
    return redirect('todo_detail', pk = parent_id)</pre></code>
        <p>In order to return to the todo detail page, you must first save the parent_id because once that child id
            is deleted, nothing in the database that was attached to it will be accessible anymore.</p>
        <code>path('todo/&ltcode>/delete', views.todo_delete, name = 'todo_delete'),</code> <br/>
           <code> path('item/&ltint:pk>/delete', views.item_delete, name = 'item_delete'),</code>
        <code><pre>
 &ltul>
        {% for item in todo.items.all %}
        &ltli>&lta href="{% url 'item_update' pk=item.pk %}">{{ item.task }}&lt/a>
            &ltform action="{% url 'item_delete' pk=item.pk %}" method="POST">
                {% csrf_token %}
                &ltinput type="submit" value="Remove {{item.task}}">
            &lt/form>
        &ltbr/> &lt/li>
        {% endfor %}
    &lt/ul>
        </pre></code>
    </section>
    <section class="main-section" id="connecting_stylesheet">
    <header class="heading">Connecting a Stylesheet</header>
    </section>
    <section class="main-section" id="deploy">
        <header class="heading">Deploy!</header>
    </section>
    <section class="main-section" id="credits_and_links">
        <header class="heading">Credits & Links</header>
        <p>Please visit the deployed application on Heroku
            <a href="" >honeyDo-django</a> and feel free to submit comments or improvements via an issue in the
            <a href="https://github.com/spianoDev/honeyDo-django"> honeyDo-django GitHub</a> Repo.
        </p>
    </section>

</main>

</body>
</html>
